#!/usr/bin/env python3

import yaml
import sys

if len(sys.argv) < 4:
    print("Usage: {} <os> <arch> <compiler> [<tag>]".format(sys.argv[0]))
    sys.exit(1)

# read target OS, architecture, compiler, and optional tag from CLI args
target_os, target_arch, target_compiler = sys.argv[1], sys.argv[2], sys.argv[3]
target_tag = sys.argv[4] if len(sys.argv) == 5 else None

# load the spack environment template
yaml_template = yaml.safe_load(open("spack-template.yaml"))
spack = yaml_template["spack"]

def getitem(d, kpath):
    kpath = kpath.split("/") if not isinstance(kpath, list) else kpath
    while len(kpath) > 0:
        k = kpath.pop(0)
        if k in d.keys():
            d = d[k]
            continue
        return None
    return d

# determine which actions are required to create the desired spack environment
actions = []
for k in yaml_template.keys():
    if k == "spack":
        continue

    ss = k.split('-')

    if len(ss) != 2:
        print("error: invalid format: ignoring {}".format(k))
        continue
    
    tag, op = ss[0], ss[1]

    if op not in ("exclude", "overwrite"):
        continue # only handle exclude or overwrite

    if tag not in (target_arch, target_tag):
        continue # only match on target_arch and target_tag

    if not isinstance(yaml_template[k], dict):
        continue

    s = ["{}/{}".format(k, d) for d in yaml_template[k].keys()]

    while len(s) > 0:
        d = s.pop()
        kpath = d.split("/")
        i = getitem(yaml_template, d)

        if isinstance(i, dict):
            s += ["{}/{}".format(d,k) for k in i.keys()]
            continue
        
        if isinstance(i, list):
            if op == "overwrite":
                actions.append((op, kpath, i))
                continue

            if len(i) <= 0:
                # not handling empty list (nothing to exclude)
                continue

            if isinstance(i[0], list):
                # not handling list-of-lists
                continue

            if isinstance(i[0], dict):
                # not handling list-of-dicts
                continue
        else:
            # non-list, non-dict
            if op == "overwrite":
                actions.append((op, kpath, i))
            continue
        
        actions.append((op, kpath, i))

# perform the actions required to create the desired spack environment
for (op, kpath, v) in actions:
    kpath = kpath[1:]
    o = spack
    while len(kpath) > 0:
        if len(kpath) == 1:
            x = kpath.pop(0)
            if op == "overwrite":
                o[x] = v
            elif op == "exclude":
                o[x] = [z for z in o[x] if z not in v]

        else:
            x = kpath.pop(0)
            if x in o:
                o = o[x]
            elif op == "overwrite":
                o[x] = {}
                o = o[x]
            else:
                break

# move templated spack:specs into an E4S spec definition block, along with a seperate definition for the target arch spec
#spack['definitions'] = [
#    { "e4s": spack['specs'] },
#    { "arch": ["%{compiler} arch=linux-{os}-{arch}".format(compiler=target_compiler, os=target_os, arch=target_arch)] }
#]

#spack['specs'] = [
#    "{} %{compiler} arch=linux-{os}-{arch}".format(x, compiler=target_compiler, os=target_os, arch=target_arch)
#    for x in spack['specs']
#]

# set spack:specs to be the matrix of (e4s specs x target arch spec)
#spack['specs'] = [ {"matrix": [ ['$e4s'], ['$arch'] ] } ]

# save the newly generated spack environment
with open('spack.yaml', 'w') as fs:
    yaml.dump({"spack": spack}, fs, default_flow_style=False)
